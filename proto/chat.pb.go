// Code generated by protoc-gen-go.
// source: chat.proto
// DO NOT EDIT!

/*
Package chat is a generated protocol buffer package.

It is generated from these files:
	chat.proto

It has these top-level messages:
	None
	AuthReq
	AuthRes
	ConnectReq
	JoinGroupReq
	JoinGroupRes
	LeaveGroupReq
	Msg
*/
package chat

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AuthType int32

const (
	AuthType_NAME_PWD   AuthType = 0
	AuthType_EMAIL_PWD  AuthType = 1
	AuthType_PHONE_PWD  AuthType = 2
	AuthType_PHONE_CODE AuthType = 3
)

var AuthType_name = map[int32]string{
	0: "NAME_PWD",
	1: "EMAIL_PWD",
	2: "PHONE_PWD",
	3: "PHONE_CODE",
}
var AuthType_value = map[string]int32{
	"NAME_PWD":   0,
	"EMAIL_PWD":  1,
	"PHONE_PWD":  2,
	"PHONE_CODE": 3,
}

func (x AuthType) String() string {
	return proto.EnumName(AuthType_name, int32(x))
}
func (AuthType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ContentType int32

const (
	ContentType_TEXT  ContentType = 0
	ContentType_IMAGE ContentType = 1
)

var ContentType_name = map[int32]string{
	0: "TEXT",
	1: "IMAGE",
}
var ContentType_value = map[string]int32{
	"TEXT":  0,
	"IMAGE": 1,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}
func (ContentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type None struct {
}

func (m *None) Reset()                    { *m = None{} }
func (m *None) String() string            { return proto.CompactTextString(m) }
func (*None) ProtoMessage()               {}
func (*None) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type AuthReq struct {
	AuthType  AuthType `protobuf:"varint,1,opt,name=auth_type,json=authType,enum=chat.AuthType" json:"auth_type,omitempty"`
	AuthKey   string   `protobuf:"bytes,2,opt,name=auth_key,json=authKey" json:"auth_key,omitempty"`
	AuthValue string   `protobuf:"bytes,3,opt,name=auth_value,json=authValue" json:"auth_value,omitempty"`
}

func (m *AuthReq) Reset()                    { *m = AuthReq{} }
func (m *AuthReq) String() string            { return proto.CompactTextString(m) }
func (*AuthReq) ProtoMessage()               {}
func (*AuthReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// auth response
type AuthRes struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Uid       uint64 `protobuf:"varint,2,opt,name=uid" json:"uid,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *AuthRes) Reset()                    { *m = AuthRes{} }
func (m *AuthRes) String() string            { return proto.CompactTextString(m) }
func (*AuthRes) ProtoMessage()               {}
func (*AuthRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ConnectReq struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
}

func (m *ConnectReq) Reset()                    { *m = ConnectReq{} }
func (m *ConnectReq) String() string            { return proto.CompactTextString(m) }
func (*ConnectReq) ProtoMessage()               {}
func (*ConnectReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type JoinGroupReq struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	Url       string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
}

func (m *JoinGroupReq) Reset()                    { *m = JoinGroupReq{} }
func (m *JoinGroupReq) String() string            { return proto.CompactTextString(m) }
func (*JoinGroupReq) ProtoMessage()               {}
func (*JoinGroupReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type JoinGroupRes struct {
	GroupId uint64 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
}

func (m *JoinGroupRes) Reset()                    { *m = JoinGroupRes{} }
func (m *JoinGroupRes) String() string            { return proto.CompactTextString(m) }
func (*JoinGroupRes) ProtoMessage()               {}
func (*JoinGroupRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type LeaveGroupReq struct {
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId" json:"session_id,omitempty"`
	GroupId   uint64 `protobuf:"varint,2,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
}

func (m *LeaveGroupReq) Reset()                    { *m = LeaveGroupReq{} }
func (m *LeaveGroupReq) String() string            { return proto.CompactTextString(m) }
func (*LeaveGroupReq) ProtoMessage()               {}
func (*LeaveGroupReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type Msg struct {
	MsgId       uint64      `protobuf:"varint,1,opt,name=msg_id,json=msgId" json:"msg_id,omitempty"`
	FromUid     uint64      `protobuf:"varint,2,opt,name=from_uid,json=fromUid" json:"from_uid,omitempty"`
	DestId      uint64      `protobuf:"varint,3,opt,name=dest_id,json=destId" json:"dest_id,omitempty"`
	ContentType ContentType `protobuf:"varint,4,opt,name=content_type,json=contentType,enum=chat.ContentType" json:"content_type,omitempty"`
	Content     string      `protobuf:"bytes,5,opt,name=content" json:"content,omitempty"`
	Name        string      `protobuf:"bytes,6,opt,name=name" json:"name,omitempty"`
}

func (m *Msg) Reset()                    { *m = Msg{} }
func (m *Msg) String() string            { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()               {}
func (*Msg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*None)(nil), "chat.None")
	proto.RegisterType((*AuthReq)(nil), "chat.AuthReq")
	proto.RegisterType((*AuthRes)(nil), "chat.AuthRes")
	proto.RegisterType((*ConnectReq)(nil), "chat.ConnectReq")
	proto.RegisterType((*JoinGroupReq)(nil), "chat.JoinGroupReq")
	proto.RegisterType((*JoinGroupRes)(nil), "chat.JoinGroupRes")
	proto.RegisterType((*LeaveGroupReq)(nil), "chat.LeaveGroupReq")
	proto.RegisterType((*Msg)(nil), "chat.Msg")
	proto.RegisterEnum("chat.AuthType", AuthType_name, AuthType_value)
	proto.RegisterEnum("chat.ContentType", ContentType_name, ContentType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Chat service

type ChatClient interface {
	Auth(ctx context.Context, in *AuthReq, opts ...grpc.CallOption) (*AuthRes, error)
	Connect(ctx context.Context, in *ConnectReq, opts ...grpc.CallOption) (Chat_ConnectClient, error)
	Unicast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*Msg, error)
	Broadcast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*Msg, error)
	JoinGroup(ctx context.Context, in *JoinGroupReq, opts ...grpc.CallOption) (*JoinGroupRes, error)
	LeaveGroup(ctx context.Context, in *LeaveGroupReq, opts ...grpc.CallOption) (*None, error)
}

type chatClient struct {
	cc *grpc.ClientConn
}

func NewChatClient(cc *grpc.ClientConn) ChatClient {
	return &chatClient{cc}
}

func (c *chatClient) Auth(ctx context.Context, in *AuthReq, opts ...grpc.CallOption) (*AuthRes, error) {
	out := new(AuthRes)
	err := grpc.Invoke(ctx, "/chat.Chat/Auth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) Connect(ctx context.Context, in *ConnectReq, opts ...grpc.CallOption) (Chat_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Chat_serviceDesc.Streams[0], c.cc, "/chat.Chat/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &chatConnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Chat_ConnectClient interface {
	Recv() (*Msg, error)
	grpc.ClientStream
}

type chatConnectClient struct {
	grpc.ClientStream
}

func (x *chatConnectClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *chatClient) Unicast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*Msg, error) {
	out := new(Msg)
	err := grpc.Invoke(ctx, "/chat.Chat/Unicast", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) Broadcast(ctx context.Context, in *Msg, opts ...grpc.CallOption) (*Msg, error) {
	out := new(Msg)
	err := grpc.Invoke(ctx, "/chat.Chat/Broadcast", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) JoinGroup(ctx context.Context, in *JoinGroupReq, opts ...grpc.CallOption) (*JoinGroupRes, error) {
	out := new(JoinGroupRes)
	err := grpc.Invoke(ctx, "/chat.Chat/JoinGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatClient) LeaveGroup(ctx context.Context, in *LeaveGroupReq, opts ...grpc.CallOption) (*None, error) {
	out := new(None)
	err := grpc.Invoke(ctx, "/chat.Chat/LeaveGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Chat service

type ChatServer interface {
	Auth(context.Context, *AuthReq) (*AuthRes, error)
	Connect(*ConnectReq, Chat_ConnectServer) error
	Unicast(context.Context, *Msg) (*Msg, error)
	Broadcast(context.Context, *Msg) (*Msg, error)
	JoinGroup(context.Context, *JoinGroupReq) (*JoinGroupRes, error)
	LeaveGroup(context.Context, *LeaveGroupReq) (*None, error)
}

func RegisterChatServer(s *grpc.Server, srv ChatServer) {
	s.RegisterService(&_Chat_serviceDesc, srv)
}

func _Chat_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Chat/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).Auth(ctx, req.(*AuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConnectReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServer).Connect(m, &chatConnectServer{stream})
}

type Chat_ConnectServer interface {
	Send(*Msg) error
	grpc.ServerStream
}

type chatConnectServer struct {
	grpc.ServerStream
}

func (x *chatConnectServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func _Chat_Unicast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Msg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).Unicast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Chat/Unicast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).Unicast(ctx, req.(*Msg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_Broadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Msg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).Broadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Chat/Broadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).Broadcast(ctx, req.(*Msg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_JoinGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).JoinGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Chat/JoinGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).JoinGroup(ctx, req.(*JoinGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Chat_LeaveGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServer).LeaveGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chat.Chat/LeaveGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServer).LeaveGroup(ctx, req.(*LeaveGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Chat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.Chat",
	HandlerType: (*ChatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Auth",
			Handler:    _Chat_Auth_Handler,
		},
		{
			MethodName: "Unicast",
			Handler:    _Chat_Unicast_Handler,
		},
		{
			MethodName: "Broadcast",
			Handler:    _Chat_Broadcast_Handler,
		},
		{
			MethodName: "JoinGroup",
			Handler:    _Chat_JoinGroup_Handler,
		},
		{
			MethodName: "LeaveGroup",
			Handler:    _Chat_LeaveGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _Chat_Connect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 608 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0x51, 0x6e, 0xd3, 0x40,
	0x10, 0xad, 0x13, 0x37, 0x8e, 0xa7, 0x4d, 0x64, 0xa6, 0xaa, 0x9a, 0x06, 0x2a, 0x55, 0xfb, 0x55,
	0x52, 0xa9, 0x81, 0xc2, 0x57, 0x85, 0x80, 0x34, 0x0d, 0x6d, 0xa0, 0x49, 0x2b, 0xab, 0x05, 0xfe,
	0x22, 0x37, 0x5e, 0x1c, 0x43, 0xb2, 0x9b, 0x66, 0x37, 0x95, 0xf2, 0xcb, 0x15, 0x38, 0x02, 0x57,
	0xe0, 0x26, 0x5c, 0x81, 0x83, 0xa0, 0xdd, 0x75, 0xec, 0x44, 0xa0, 0xc2, 0xdf, 0xbc, 0x99, 0x79,
	0x6f, 0xd6, 0x33, 0x4f, 0x06, 0xe8, 0x0f, 0x02, 0x79, 0x30, 0x9e, 0x70, 0xc9, 0xd1, 0x56, 0x71,
	0xf5, 0x51, 0xc4, 0x79, 0x34, 0xa4, 0xf5, 0x60, 0x1c, 0xd7, 0x03, 0xc6, 0xb8, 0x0c, 0x64, 0xcc,
	0x99, 0x30, 0x3d, 0xa4, 0x00, 0x76, 0x97, 0x33, 0x4a, 0xc6, 0xe0, 0x34, 0xa6, 0x72, 0xe0, 0xd3,
	0x5b, 0xdc, 0x07, 0x37, 0x98, 0xca, 0x41, 0x4f, 0xce, 0xc6, 0xb4, 0x62, 0xed, 0x5a, 0x7b, 0xe5,
	0xc3, 0xf2, 0x81, 0x96, 0x55, 0x1d, 0x57, 0xb3, 0x31, 0xf5, 0x8b, 0x41, 0x12, 0xe1, 0x36, 0xe8,
	0xb8, 0xf7, 0x85, 0xce, 0x2a, 0xb9, 0x5d, 0x6b, 0xcf, 0xf5, 0x1d, 0x85, 0xdf, 0xd1, 0x19, 0xee,
	0x00, 0xe8, 0xd2, 0x5d, 0x30, 0x9c, 0xd2, 0x4a, 0x5e, 0x17, 0xb5, 0xf2, 0x7b, 0x95, 0x20, 0xdd,
	0xf9, 0x44, 0xa1, 0x3a, 0x05, 0x15, 0x22, 0xe6, 0xac, 0x17, 0x87, 0x7a, 0xa4, 0xeb, 0xbb, 0x49,
	0xa6, 0x1d, 0xa2, 0x07, 0xf9, 0x69, 0x1c, 0x6a, 0x79, 0xdb, 0x57, 0x21, 0x22, 0xd8, 0x2c, 0x18,
	0xcd, 0x45, 0x75, 0x4c, 0xf6, 0x01, 0x9a, 0x9c, 0x31, 0xda, 0x97, 0xea, 0x23, 0xee, 0x97, 0x24,
	0xaf, 0x60, 0xfd, 0x2d, 0x8f, 0xd9, 0xe9, 0x84, 0x4f, 0xc7, 0xff, 0x6e, 0xd7, 0x2f, 0x98, 0x0c,
	0x93, 0x0f, 0x54, 0x21, 0x79, 0xbc, 0x24, 0x20, 0xd4, 0x1e, 0x22, 0x15, 0xcf, 0xe9, 0xb6, 0xef,
	0x68, 0xdc, 0x0e, 0x49, 0x1b, 0x4a, 0xe7, 0x34, 0xb8, 0xa3, 0xff, 0x3b, 0x6c, 0x51, 0x2a, 0xb7,
	0x2c, 0xf5, 0xc3, 0x82, 0x7c, 0x47, 0x44, 0xb8, 0x09, 0x85, 0x91, 0x88, 0xb2, 0x59, 0xab, 0x23,
	0x11, 0x19, 0xe6, 0xa7, 0x09, 0x1f, 0xf5, 0xb2, 0x6d, 0x39, 0x0a, 0x5f, 0xc7, 0x21, 0x6e, 0x81,
	0x13, 0x52, 0x21, 0x15, 0x25, 0xaf, 0x2b, 0x05, 0x05, 0xdb, 0x21, 0x3e, 0x87, 0xf5, 0x3e, 0x67,
	0x92, 0x32, 0x69, 0x0e, 0x6e, 0xeb, 0x83, 0x3f, 0x30, 0x07, 0x6f, 0x9a, 0x8a, 0xbe, 0xf9, 0x5a,
	0x3f, 0x03, 0x58, 0x01, 0x27, 0x81, 0x95, 0x55, 0x73, 0xf5, 0x04, 0xa6, 0xa7, 0x29, 0x64, 0xa7,
	0xa9, 0xbd, 0x81, 0xe2, 0xdc, 0x3a, 0xb8, 0x0e, 0xc5, 0x6e, 0xa3, 0xd3, 0xea, 0x5d, 0x7e, 0x38,
	0xf1, 0x56, 0xb0, 0x04, 0x6e, 0xab, 0xd3, 0x68, 0x9f, 0x6b, 0x68, 0x29, 0x78, 0x79, 0x76, 0xd1,
	0x35, 0xd5, 0x1c, 0x96, 0x01, 0x0c, 0x6c, 0x5e, 0x9c, 0xb4, 0xbc, 0x7c, 0x8d, 0xc0, 0xda, 0xc2,
	0x8b, 0xb0, 0x08, 0xf6, 0x55, 0xeb, 0xe3, 0x95, 0xb7, 0x82, 0x2e, 0xac, 0xb6, 0x3b, 0x8d, 0xd3,
	0x96, 0x67, 0x1d, 0x7e, 0xcf, 0x83, 0xdd, 0x1c, 0x04, 0x12, 0x5f, 0x82, 0xad, 0x86, 0x62, 0x29,
	0xf3, 0xae, 0x4f, 0x6f, 0xab, 0x4b, 0x50, 0x90, 0xca, 0xd7, 0x9f, 0xbf, 0xbe, 0xe5, 0x90, 0x94,
	0xea, 0x77, 0x4f, 0xeb, 0xaa, 0x52, 0x57, 0x0e, 0x3d, 0xb2, 0x6a, 0x78, 0x0c, 0x4e, 0xe2, 0x27,
	0xf4, 0xd2, 0x6d, 0x24, 0xf6, 0xaa, 0xba, 0x26, 0xd3, 0x11, 0xd1, 0x5c, 0x01, 0xbd, 0x54, 0xa1,
	0x6f, 0xfa, 0x9e, 0x58, 0xf8, 0x02, 0x9c, 0x6b, 0x16, 0xf7, 0x03, 0x21, 0x31, 0x63, 0x2c, 0x92,
	0x1f, 0x6a, 0xf2, 0x26, 0xc9, 0xc8, 0x53, 0xd3, 0xaf, 0x5e, 0xf0, 0x1a, 0xdc, 0xe3, 0x09, 0x0f,
	0xc2, 0x7b, 0xf8, 0x3b, 0x9a, 0xbf, 0x45, 0x30, 0xe5, 0xdf, 0xcc, 0x19, 0x4a, 0xa1, 0x03, 0x6e,
	0xea, 0x52, 0x44, 0x43, 0x5b, 0xf4, 0x7d, 0xf5, 0xcf, 0xdc, 0xdf, 0x56, 0xf2, 0x99, 0xc7, 0x4c,
	0xc9, 0x9d, 0x01, 0x64, 0x4e, 0xc6, 0x0d, 0xc3, 0x5d, 0xf2, 0x76, 0x15, 0x4c, 0x52, 0xff, 0x53,
	0xb6, 0xb5, 0xd0, 0x06, 0x29, 0xa7, 0x42, 0x43, 0xd5, 0x7b, 0x64, 0xd5, 0x6e, 0x0a, 0xfa, 0xef,
	0xf3, 0xec, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x7d, 0x12, 0x1a, 0xaf, 0x04, 0x00, 0x00,
}
